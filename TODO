- Triangle primitive



- Two-stage ray tracing, similar to the Rayes (not Reyes) paper
	//- Implement an alternative BVH traversal which can be resumed for a ray.
	//  May require modifying rays to be traversal-aware.
	//- Implement BVH method to return "next n leaf node hits".
	//- Change Tracer to use this stuff in a naive useless way, to verify.
	- Make min_t/max_t ray updating the responsibility of the Tracer, not the primitives
	- Refactor data structures to pass around minimal data when handling the 
	  ray reordering strategy.
	- Refactor primitive intersection code to use per-thread data caches, handling
	  all dynamic data generation in those per-thread caches.
	- Multi-thread ray tracing

- Migrate all render configuration data to Renderer

- Simple scene-description format

- Propagation of ray differentials on bounces

- Adaptive sampling scheme

//- Create Transform class

- Simple material system (for testing purposes
  only, eventually replace with OSL)

- Refactor TimeBox template to use class methods for interpolation

- Multi-threaded rendering

- OSL integration

- More compact and/or faster BVH:
	- Quantized BVH?
	- MSBVH?
	- QBVH?
	- SSH?
	- Quantized MSQSSH?  Ha ha ha.
	- Must be able to pause and resume traversal with minimal data per ray

- Faster sorting of potential ray intersections
	- Counting sort
		- Big benefit of counting sort is we automatically get the starting
		  indices in the potential intersections array for each object.
		- http://www.drdobbs.com/architecture-and-design/parallel-counting-sort/224700144
		- http://www.drdobbs.com/parallel/parallel-counting-sort-part-2/225900071

